# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/ipaddress/all/ipaddress.rbi
#
# ipaddress-0.8.3

module IPAddress
  def ipv4?; end
  def ipv6?; end
  def self.deprecate(message = nil); end
  def self.ntoa(uint); end
  def self.parse(str); end
  def self.valid?(addr); end
  def self.valid_ipv4?(addr); end
  def self.valid_ipv4_netmask?(addr); end
  def self.valid_ipv6?(addr); end
end
class IPAddress::Prefix
  def +(oth); end
  def -(oth); end
  def <=>(oth); end
  def initialize(num); end
  def inspect; end
  def prefix; end
  def to_i; end
  def to_s; end
  include Comparable
end
class IPAddress::Prefix32 < IPAddress::Prefix
  def [](index); end
  def bits; end
  def host_prefix; end
  def hostmask; end
  def initialize(num); end
  def octets; end
  def self.parse_netmask(netmask); end
  def to_ip; end
  def to_u32; end
end
class IPAddress::Prefix128 < IPAddress::Prefix
  def bits; end
  def host_prefix; end
  def initialize(num = nil); end
  def to_u128; end
end
class IPAddress::IPv4
  def +(oth); end
  def -(oth); end
  def /(subnets = nil); end
  def <=>(oth); end
  def [](index); end
  def []=(index, value); end
  def a?; end
  def address; end
  def aggregate(ip1, ip2); end
  def arpa; end
  def b?; end
  def bits; end
  def broadcast; end
  def broadcast_u32; end
  def c?; end
  def data; end
  def each; end
  def each_host; end
  def first; end
  def hex(space = nil); end
  def hosts; end
  def include?(oth); end
  def include_all?(*others); end
  def initialize(str); end
  def last; end
  def loopback?; end
  def multicast?; end
  def netmask; end
  def netmask=(addr); end
  def network; end
  def network?; end
  def network_u32; end
  def newprefix(num); end
  def octet(index); end
  def octet=(index, value); end
  def octets; end
  def prefix; end
  def prefix=(num); end
  def private?; end
  def reverse; end
  def self.extract(str); end
  def self.parse_classful(ip); end
  def self.parse_data(str, prefix = nil); end
  def self.parse_u32(u32, prefix = nil); end
  def self.summarize(*args); end
  def size; end
  def split(subnets = nil); end
  def subnet(subprefix); end
  def sum_first_found(arr); end
  def supernet(new_prefix); end
  def to(e); end
  def to_h(space = nil); end
  def to_hex(space = nil); end
  def to_i; end
  def to_ipv6; end
  def to_s; end
  def to_string; end
  def to_u32; end
  def u32; end
  include Comparable
  include Enumerable
  include IPAddress
end
class IPAddress::IPv6
  def <=>(oth); end
  def [](index); end
  def []=(index, value); end
  def address; end
  def arpa; end
  def bits; end
  def broadcast_u128; end
  def compress_address; end
  def compressed; end
  def data; end
  def each; end
  def group(index); end
  def group=(index, value); end
  def groups; end
  def hexs; end
  def include?(oth); end
  def initialize(str); end
  def literal; end
  def loopback?; end
  def mapped?; end
  def network; end
  def network?; end
  def network_u128; end
  def prefix; end
  def prefix=(num); end
  def reverse; end
  def self.compress(str); end
  def self.expand(str); end
  def self.groups(str); end
  def self.parse_data(str); end
  def self.parse_hex(hex, prefix = nil); end
  def self.parse_u128(u128, prefix = nil); end
  def size; end
  def to_hex; end
  def to_i; end
  def to_s; end
  def to_string; end
  def to_string_uncompressed; end
  def to_u128; end
  def unspecified?; end
  include Comparable
  include Enumerable
  include IPAddress
end
class IPAddress::IPv6::Unspecified < IPAddress::IPv6
  def initialize; end
end
class IPAddress::IPv6::Loopback < IPAddress::IPv6
  def initialize; end
end
class IPAddress::IPv6::Mapped < IPAddress::IPv6
  def initialize(str); end
  def ipv4; end
  def mapped?; end
  def to_s; end
  def to_string; end
end
class Object < BasicObject
  def IPAddress(str); end
end
